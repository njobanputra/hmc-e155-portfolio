[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Beginning of Semester reflection\n\n\nWhat I hope and fear in this class\n\n\n\n\n\nAug 28, 2025\n\n\nNina Jobanputra\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Nina Jobanputra is a current senior at Harvey Mudd College. Nina has taken many electrical engineering classes; Introduction to analog design, Radio Frequency circuit design, Principles of computer science, Data structures/Program developement and now Microprocessor Systems: Design and Applications. Nina has worked in a variety of fields but after graduation wants to work in medical devices or Biotech as an electrical engineer, but who knows what will happen after this year."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Introduction",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI tested the circuit and I was able to get the simultaneous display. One hiccup I ran into was the pin out for the display module was a bit hard to read so I ended up accidentally rewiring one side of the display wrong. I believe in total I spent about 15 hours on this lab, which is a great improvement from last week.\nHere are my outputs from my testbenches:\n\nSeven Segment waves\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "labs/lab2/lab2.html#displaymulti-waves",
    "href": "labs/lab2/lab2.html#displaymulti-waves",
    "title": "Introduction",
    "section": "DisplayMulti waves",
    "text": "DisplayMulti waves\n\n\n\n\n\n\nFigure 4"
  },
  {
    "objectID": "labs/lab2/lab2.html#ledsum-waves",
    "href": "labs/lab2/lab2.html#ledsum-waves",
    "title": "Introduction",
    "section": "ledSum waves",
    "text": "ledSum waves\n\n\n\n\n\n\nFigure 5"
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype",
    "href": "labs/lab2/lab2.html#ai-prototype",
    "title": "Introduction",
    "section": "AI Prototype",
    "text": "AI Prototype\nI gave ChatGPT the prompt, “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.” and got the follwoing code:\n    module seven_seg_multiplexer (\n        input logic clk,\n        input logic reset,\n        input logic [3:0] in1,  // Input for display 1\n        input logic [3:0] in2,  // Input for display 2\n        output logic [6:0] seg, // 7-segment outputs (a to g), active low\n        output logic [1:0] an   // Display enable signals (active low)\n    );\n\n    // Internal signal to track which digit is active\n    logic select;  // 0 -&gt; display 1, 1 -&gt; display 2\n    logic [3:0] digit;\n    logic [6:0] seg_out;\n\n    // Simple clock divider for multiplexing (~1 kHz)\n    logic [15:0] clk_div;\n   \n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            clk_div &lt;= 0;\n            select &lt;= 0;\n        end else begin\n            clk_div &lt;= clk_div + 1;\n            if (clk_div == 0)\n                select &lt;= ~select;\n        end\n    end\n\n    // Choose which digit to decode\n    always_comb begin\n        case (select)\n            1'b0: digit = in1;\n            1'b1: digit = in2;\n            default: digit = 4'b0000;\n        endcase\n    end\n\n    // 7-segment decoder (active low for common anode)\n    always_comb begin\n        case (digit)\n            4'h0: seg_out = 7'b0000001;\n            4'h1: seg_out = 7'b1001111;\n            4'h2: seg_out = 7'b0010010;\n            4'h3: seg_out = 7'b0000110;\n            4'h4: seg_out = 7'b1001100;\n            4'h5: seg_out = 7'b0100100;\n            4'h6: seg_out = 7'b0100000;\n            4'h7: seg_out = 7'b0001111;\n            4'h8: seg_out = 7'b0000000;\n            4'h9: seg_out = 7'b0000100;\n            4'hA: seg_out = 7'b0001000;\n            4'hB: seg_out = 7'b1100000;\n            4'hC: seg_out = 7'b0110001;\n            4'hD: seg_out = 7'b1000010;\n            4'hE: seg_out = 7'b0110000;\n            4'hF: seg_out = 7'b0111000;\n            default: seg_out = 7'b1111111;  // Blank\n        endcase\n    end\n\n    // Output assignment\n    always_comb begin\n        seg = seg_out;\n\n        case (select)\n            1'b0: an = 2'b10;  // Enable display 0 (active low)\n            1'b1: an = 2'b01;  // Enable display 1 (active low)\n            default: an = 2'b11;\n        endcase\n    end\n\nendmodule\nI then synthesized it and to my surprise it actually compiled. I also asked ChatGPT to give me a testbench. The test bench ultimately failed so there must be a mistake in the actual code. I did notice that ChatGPT only gave me the top module and basically put the entire lab into 1 file which is a huge mistake in this class.\nI then asked a different ChatGPT the following prompt, “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.” Here is the code it produced:\n    // seven_seg_multiplexer.sv\n    // Time-multiplex a single seven-seg decoder to drive two separate displays.\n    //\n    // Assumptions:\n    //  - Target displays are common-anode (segment outputs are active-low).\n    //  - Provided modules:\n    //      * oscillator with output named \"osc_out\" (1-bit clock-like signal)\n    //      * seven_seg_decoder with ports (input  [3:0] bcd, output [6:0] segments)\n    //    If your provided module names/port names differ, adjust the instantiations.\n    //  - Inputs: in1 -&gt; physical display 0, in2 -&gt; physical display 1\n    //  - \"an\" outputs are active-low enables for each display (an[0] -&gt; display 0, an[1] -&gt; display 1)\n\n    module seven_seg_multiplexer (\n        input  logic       clk,    // primary system clock (not strictly required if oscillator used)\n        input  logic       reset,  // synchronous active-high reset\n        input  logic [3:0] in1,    // nibble for display 0\n        input  logic [3:0] in2,    // nibble for display 1\n        output logic [6:0] seg,    // segments a..g (active low)\n        output logic [1:0] an      // digit enables (active low). an[0] -&gt; display 0, an[1] -&gt; display 1\n    );\n\n        // Internal select: 0 =&gt; show in1 on segments, 1 =&gt; show in2\n        logic select;\n\n        // Digit currently being decoded\n        logic [3:0] digit;\n\n        // Output of the external seven-seg decoder (assumed active-low segments [6:0])\n        logic [6:0] seg_decoder_out;\n\n        // Oscillator instance output (used to toggle select)\n        logic osc_clk; // oscillator output (treated as a clock-like pulse)\n\n        // Optional: If you want to use the system clock for a divider instead of oscillator,\n        // comment out the oscillator instantiation and use clk_div logic below.\n        //\n        // Instantiate provided oscillator (adjust module/port names if different).\n        // Example assumed module: module oscillator(output logic osc_out);\n        oscillator u_osc (\n            .osc_out(osc_clk)\n        );\n\n        // If oscillator module is not available or you prefer a divider from `clk`, uncomment:\n        // logic [15:0] clk_div;\n        // always_ff @(posedge clk or posedge reset) begin\n        //     if (reset) clk_div &lt;= 16'd0;\n        //     else        clk_div &lt;= clk_div + 1;\n        // end\n        // // use a chosen bit of clk_div as the multiplex toggle (e.g., clk_div[12])\n        // assign osc_clk = clk_div[12];\n\n        // Toggle select on rising edge of osc_clk (synchronous to osc_clk)\n        // Use an edge detector to create a clean toggle on each osc_clk rising edge.\n        logic osc_clk_d;\n        always_ff @(posedge clk or posedge reset) begin\n            if (reset) begin\n                osc_clk_d &lt;= 1'b0;\n                select    &lt;= 1'b0;\n            end else begin\n                // sample oscillator into clk domain (simple synchronizer)\n                osc_clk_d &lt;= osc_clk;\n                // toggle select on rising edge of osc_clk (detected in clk domain)\n                if (~osc_clk_d & osc_clk)\n                    select &lt;= ~select;\n            end\n        end\n\n        // Choose which input nibble to decode based on select\n        always_comb begin\n            case (select)\n                1'b0: digit = in1;\n                1'b1: digit = in2;\n                default: digit = 4'h0;\n            endcase\n        end\n\n        // Instantiate provided 4-&gt;7 segment decoder\n        // Assumed module signature: module seven_seg_decoder(input [3:0] bcd, output [6:0] segments);\n        seven_seg_decoder u_decoder (\n            .bcd(digit),\n            .segments(seg_decoder_out)\n        );\n\n        // Drive outputs (seg and an). Segments are driven directly from the decoder (active-low).\n        always_comb begin\n            seg = seg_decoder_out;\n\n            // Active-low anodes: assert the active digit low, other(s) high.\n            // an[0] corresponds to in1/display 0; an[1] is in2/display 1.\n            if (select == 1'b0) begin\n                an = 2'b10; // enable display 0 (an[0] = 0), disable display 1 (an[1] = 1)\n            end else begin\n                an = 2'b01; // enable display 1 (an[1] = 0), disable display 0 (an[0] = 1)\n            end\n        end\n\n    endmodule\nSimilar to before it only used 1 file. I created a new project and tried to synthesize the design. It failed because the path to the oscillator got messed up.\nOverall, I’m surprised at how well AI did but I’m not surprised that it didn’t get the lab entirely right. One thing that probably helped the model out is that this is a pretty common project and so there are tons of open source verisions of this project online."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Introduction",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI tested the circuit and I was able to get all the segments to light up and control them through the dip switches. Additionally, the LEDs also worked as planned.\n\nLED0 waves\n\n\n\n\n\n\nFigure 4\n\n\n\n\n\nLED1 waves\n\n\n\n\n\n\nFigure 5\n\n\n\n\n\nSeven Segment waves\n\n\n\n\n\n\nFigure 6\n\n\n\nI think I spent a total of 25-27 hours on this lab. I ran into major issues with programming the FPGA which ended up gating me for about 4 days. Overall, the main difficulty of this lab was getting the platforms to work and getting myself familiar with them.\n\n\nAI prototype\nI used the given the prompt, “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg,” and gave it to ChatGPT. I chose ChatGPT because it is free for a certain number of questions. It gave me the following code:\nmodule led_blinker_2hz (\n    output logic led\n);\n\n    // Internal oscillator signal\n    logic clk_hf;\n\n    // Instantiate the internal high-frequency oscillator\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\") // No division: 48 MHz\n    ) hfosc_inst (\n        .CLKHFEN(1'b1),   // Enable oscillator\n        .CLKHFPU(1'b1),   // Power up oscillator\n        .CLKHF(clk_hf)    // Output clock\n    );\n\n    // Counter to generate ~2 Hz blink rate from 48 MHz clock\n    localparam int COUNTER_MAX = 24_000_000; // Half period at 48 MHz\n    logic [$clog2(COUNTER_MAX)-1:0] counter = 0;\n\n    // LED state toggle\n    always_ff @(posedge clk_hf) begin\n        if (counter == COUNTER_MAX - 1) begin\n            counter &lt;= 0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\nThe first thing that I noticed about this code is that it doesn’t have a reset option in it. From my lab I found that you should definitely have a reset option so that you can put your LED into a known state. I then proceeded to point that out to the ChatGPT and it came back with more code. This output (not pictured) had some problems too. One it declared a counter number with no size or type. I could have nudged it more but I didn’t feel like it and didn’t know how to improve it because I wasn’t prompting it correctly.\nOverall I would say the output was good as a bare bones and could have helped me think about how to do the problem but I would not copy and paste the output directly. What I decided to do was give ChatGPT one of my files but I made some errors in it, more along the lines of forgetting a semicolon. ChatGPT was great at catching those errors. So if I were to ever use AI in my job I would use it as another set of eyes to debug."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Beginning of Semester reflection",
    "section": "",
    "text": "E155 is known as one of the hardest courses at mudd and so I’m defiently scared of what lies ahead. I know that this class will be hard but I hope it helps me solidfy being able to think in circuits vs code since that was a large downfall in E85. I also think being able to effectively debug a program."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This portfolio uses the Harvey Mudd College E155 site."
  },
  {
    "objectID": "resources.html#resources",
    "href": "resources.html#resources",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This portfolio uses the Harvey Mudd College E155 site."
  }
]