[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Beginning of Semester reflection\n\n\nWhat I hope and fear in this class\n\n\n\n\n\nAug 28, 2025\n\n\nNina Jobanputra\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Nina Jobanputra is a current senior at Harvey Mudd College. Nina has taken many electrical engineering classes; Introduction to analog design, Radio Frequency circuit design, Principles of computer science, Data structures/Program developement and now Microprocessor Systems: Design and Applications. Nina has worked in a variety of fields but after graduation wants to work in medical devices or Biotech as an electrical engineer, but who knows what will happen after this year."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Introduction",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI tested the circuit and I was able to get the simultaneous display. One hiccup I ran into was the pin out for the display module was a bit hard to read so I ended up accidentally rewiring one side of the display wrong. I believe in total I spent about 15 hours on this lab, which is a great improvement from last week.\nHere are my outputs from my testbenches:\n\nSeven Segment waves\n\n\n\n\n\n\nFigure 3"
  },
  {
    "objectID": "labs/lab2/lab2.html#displaymulti-waves",
    "href": "labs/lab2/lab2.html#displaymulti-waves",
    "title": "Introduction",
    "section": "DisplayMulti waves",
    "text": "DisplayMulti waves\n\n\n\n\n\n\nFigure 4"
  },
  {
    "objectID": "labs/lab2/lab2.html#ledsum-waves",
    "href": "labs/lab2/lab2.html#ledsum-waves",
    "title": "Introduction",
    "section": "ledSum waves",
    "text": "ledSum waves\n\n\n\n\n\n\nFigure 5"
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype",
    "href": "labs/lab2/lab2.html#ai-prototype",
    "title": "Introduction",
    "section": "AI Prototype",
    "text": "AI Prototype\nI gave ChatGPT the prompt, “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.” and got the follwoing code:\n    module seven_seg_multiplexer (\n        input logic clk,\n        input logic reset,\n        input logic [3:0] in1,  // Input for display 1\n        input logic [3:0] in2,  // Input for display 2\n        output logic [6:0] seg, // 7-segment outputs (a to g), active low\n        output logic [1:0] an   // Display enable signals (active low)\n    );\n\n    // Internal signal to track which digit is active\n    logic select;  // 0 -&gt; display 1, 1 -&gt; display 2\n    logic [3:0] digit;\n    logic [6:0] seg_out;\n\n    // Simple clock divider for multiplexing (~1 kHz)\n    logic [15:0] clk_div;\n   \n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            clk_div &lt;= 0;\n            select &lt;= 0;\n        end else begin\n            clk_div &lt;= clk_div + 1;\n            if (clk_div == 0)\n                select &lt;= ~select;\n        end\n    end\n\n    // Choose which digit to decode\n    always_comb begin\n        case (select)\n            1'b0: digit = in1;\n            1'b1: digit = in2;\n            default: digit = 4'b0000;\n        endcase\n    end\n\n    // 7-segment decoder (active low for common anode)\n    always_comb begin\n        case (digit)\n            4'h0: seg_out = 7'b0000001;\n            4'h1: seg_out = 7'b1001111;\n            4'h2: seg_out = 7'b0010010;\n            4'h3: seg_out = 7'b0000110;\n            4'h4: seg_out = 7'b1001100;\n            4'h5: seg_out = 7'b0100100;\n            4'h6: seg_out = 7'b0100000;\n            4'h7: seg_out = 7'b0001111;\n            4'h8: seg_out = 7'b0000000;\n            4'h9: seg_out = 7'b0000100;\n            4'hA: seg_out = 7'b0001000;\n            4'hB: seg_out = 7'b1100000;\n            4'hC: seg_out = 7'b0110001;\n            4'hD: seg_out = 7'b1000010;\n            4'hE: seg_out = 7'b0110000;\n            4'hF: seg_out = 7'b0111000;\n            default: seg_out = 7'b1111111;  // Blank\n        endcase\n    end\n\n    // Output assignment\n    always_comb begin\n        seg = seg_out;\n\n        case (select)\n            1'b0: an = 2'b10;  // Enable display 0 (active low)\n            1'b1: an = 2'b01;  // Enable display 1 (active low)\n            default: an = 2'b11;\n        endcase\n    end\n\nendmodule\nI then synthesized it and to my surprise it actually compiled. I also asked ChatGPT to give me a testbench. The test bench ultimately failed so there must be a mistake in the actual code. I did notice that ChatGPT only gave me the top module and basically put the entire lab into 1 file which is a huge mistake in this class.\nI then asked a different ChatGPT the following prompt, “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.” Here is the code it produced:\n    // seven_seg_multiplexer.sv\n    // Time-multiplex a single seven-seg decoder to drive two separate displays.\n    //\n    // Assumptions:\n    //  - Target displays are common-anode (segment outputs are active-low).\n    //  - Provided modules:\n    //      * oscillator with output named \"osc_out\" (1-bit clock-like signal)\n    //      * seven_seg_decoder with ports (input  [3:0] bcd, output [6:0] segments)\n    //    If your provided module names/port names differ, adjust the instantiations.\n    //  - Inputs: in1 -&gt; physical display 0, in2 -&gt; physical display 1\n    //  - \"an\" outputs are active-low enables for each display (an[0] -&gt; display 0, an[1] -&gt; display 1)\n\n    module seven_seg_multiplexer (\n        input  logic       clk,    // primary system clock (not strictly required if oscillator used)\n        input  logic       reset,  // synchronous active-high reset\n        input  logic [3:0] in1,    // nibble for display 0\n        input  logic [3:0] in2,    // nibble for display 1\n        output logic [6:0] seg,    // segments a..g (active low)\n        output logic [1:0] an      // digit enables (active low). an[0] -&gt; display 0, an[1] -&gt; display 1\n    );\n\n        // Internal select: 0 =&gt; show in1 on segments, 1 =&gt; show in2\n        logic select;\n\n        // Digit currently being decoded\n        logic [3:0] digit;\n\n        // Output of the external seven-seg decoder (assumed active-low segments [6:0])\n        logic [6:0] seg_decoder_out;\n\n        // Oscillator instance output (used to toggle select)\n        logic osc_clk; // oscillator output (treated as a clock-like pulse)\n\n        // Optional: If you want to use the system clock for a divider instead of oscillator,\n        // comment out the oscillator instantiation and use clk_div logic below.\n        //\n        // Instantiate provided oscillator (adjust module/port names if different).\n        // Example assumed module: module oscillator(output logic osc_out);\n        oscillator u_osc (\n            .osc_out(osc_clk)\n        );\n\n        // If oscillator module is not available or you prefer a divider from `clk`, uncomment:\n        // logic [15:0] clk_div;\n        // always_ff @(posedge clk or posedge reset) begin\n        //     if (reset) clk_div &lt;= 16'd0;\n        //     else        clk_div &lt;= clk_div + 1;\n        // end\n        // // use a chosen bit of clk_div as the multiplex toggle (e.g., clk_div[12])\n        // assign osc_clk = clk_div[12];\n\n        // Toggle select on rising edge of osc_clk (synchronous to osc_clk)\n        // Use an edge detector to create a clean toggle on each osc_clk rising edge.\n        logic osc_clk_d;\n        always_ff @(posedge clk or posedge reset) begin\n            if (reset) begin\n                osc_clk_d &lt;= 1'b0;\n                select    &lt;= 1'b0;\n            end else begin\n                // sample oscillator into clk domain (simple synchronizer)\n                osc_clk_d &lt;= osc_clk;\n                // toggle select on rising edge of osc_clk (detected in clk domain)\n                if (~osc_clk_d & osc_clk)\n                    select &lt;= ~select;\n            end\n        end\n\n        // Choose which input nibble to decode based on select\n        always_comb begin\n            case (select)\n                1'b0: digit = in1;\n                1'b1: digit = in2;\n                default: digit = 4'h0;\n            endcase\n        end\n\n        // Instantiate provided 4-&gt;7 segment decoder\n        // Assumed module signature: module seven_seg_decoder(input [3:0] bcd, output [6:0] segments);\n        seven_seg_decoder u_decoder (\n            .bcd(digit),\n            .segments(seg_decoder_out)\n        );\n\n        // Drive outputs (seg and an). Segments are driven directly from the decoder (active-low).\n        always_comb begin\n            seg = seg_decoder_out;\n\n            // Active-low anodes: assert the active digit low, other(s) high.\n            // an[0] corresponds to in1/display 0; an[1] is in2/display 1.\n            if (select == 1'b0) begin\n                an = 2'b10; // enable display 0 (an[0] = 0), disable display 1 (an[1] = 1)\n            end else begin\n                an = 2'b01; // enable display 1 (an[1] = 0), disable display 0 (an[0] = 1)\n            end\n        end\n\n    endmodule\nSimilar to before it only used 1 file. I created a new project and tried to synthesize the design. It failed because the path to the oscillator got messed up.\nOverall, I’m surprised at how well AI did but I’m not surprised that it didn’t get the lab entirely right. One thing that probably helped the model out is that this is a pretty common project and so there are tons of open source verisions of this project online."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Introduction",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI tested the circuit and I was able to get all the segments to light up and control them through the dip switches. Additionally, the LEDs also worked as planned.\n\nLED0 waves\n\n\n\n\n\n\nFigure 4\n\n\n\n\n\nLED1 waves\n\n\n\n\n\n\nFigure 5\n\n\n\n\n\nSeven Segment waves\n\n\n\n\n\n\nFigure 6\n\n\n\nI think I spent a total of 25-27 hours on this lab. I ran into major issues with programming the FPGA which ended up gating me for about 4 days. Overall, the main difficulty of this lab was getting the platforms to work and getting myself familiar with them.\n\n\nAI prototype\nI used the given the prompt, “Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg,” and gave it to ChatGPT. I chose ChatGPT because it is free for a certain number of questions. It gave me the following code:\nmodule led_blinker_2hz (\n    output logic led\n);\n\n    // Internal oscillator signal\n    logic clk_hf;\n\n    // Instantiate the internal high-frequency oscillator\n    SB_HFOSC #(\n        .CLKHF_DIV(\"0b00\") // No division: 48 MHz\n    ) hfosc_inst (\n        .CLKHFEN(1'b1),   // Enable oscillator\n        .CLKHFPU(1'b1),   // Power up oscillator\n        .CLKHF(clk_hf)    // Output clock\n    );\n\n    // Counter to generate ~2 Hz blink rate from 48 MHz clock\n    localparam int COUNTER_MAX = 24_000_000; // Half period at 48 MHz\n    logic [$clog2(COUNTER_MAX)-1:0] counter = 0;\n\n    // LED state toggle\n    always_ff @(posedge clk_hf) begin\n        if (counter == COUNTER_MAX - 1) begin\n            counter &lt;= 0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\nThe first thing that I noticed about this code is that it doesn’t have a reset option in it. From my lab I found that you should definitely have a reset option so that you can put your LED into a known state. I then proceeded to point that out to the ChatGPT and it came back with more code. This output (not pictured) had some problems too. One it declared a counter number with no size or type. I could have nudged it more but I didn’t feel like it and didn’t know how to improve it because I wasn’t prompting it correctly.\nOverall I would say the output was good as a bare bones and could have helped me think about how to do the problem but I would not copy and paste the output directly. What I decided to do was give ChatGPT one of my files but I made some errors in it, more along the lines of forgetting a semicolon. ChatGPT was great at catching those errors. So if I were to ever use AI in my job I would use it as another set of eyes to debug."
  },
  {
    "objectID": "labs/lab5/lab5.html#results-and-discussion",
    "href": "labs/lab5/lab5.html#results-and-discussion",
    "title": "Introduction",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI validated the velocity I got from my program by both counting it and taking an oscilliscope trace and doing some math. I set my motor to about 11.33V and my program showed a velocity of about 2.72 revs/second. I started a timer for about 15 seconds and counted the amount of revolutions I saw. Then I scaled that number down for 1 second which is the velocity my program was outputting. I ended up getting a velocity of about 2.667 revs/second. For the math way I started by taking an oscilscope trace.\n\n\n\n\n\n\nFigure 3: An oscilloscope trace of my interrupt signals.\n\n\n\nFigure 3 shows the interrupt signals.\nFrom the oscilloscope I measured that the frequency was 1.1KHz. Below shows my math to validte the speed through manual hand calculations.\n\n\n\n\n\n\nFigure 4: The math used to validate the velocity.\n\n\n\nFigure 4 shows the math used to validate the velocity.\n\nPolling Vs. Interrupts\nPolling is when a device is constantly checking the status of our device, so in our case it has to continually check for when it should be computing the velocity. So it is constantly it is continually sending requests to know if it is time to do something. Interrupts basically only go up and alert the program when it absolutely has to do something, otherwise it idles and does nothing. Since polling is constantly checking this results in higher latency and using up a lot more reasources. However, coding for polling is way easier to implment than the interrupts. Interrupts on the otherhand, while difficult to code are much faster and use up less reasources. In this lab, since we have to update the velocity every second, which is a short time frame but would be hard to do with polling because there would be a delay since with polling we are constantly checking when we need to do something and then we finally get the answer to do the thing, we would already be behind the interrupts.\n\n\n\n\n\n\nFigure 5: Polling frequency is 965 Hz.\n\n\n\nFigure 5 shows the oscilloscope trace that shows that my polling frequency is at 965Hz compared to my interupt frequency at double that.\nHere we see that the polling sampling frequency is much slower than the interrupt sampling frequency.\nIn all this lab successfully worked, it was able to tell the velocity somewhat accurately and provide the correct direction. I worked on the lab for about 10 hours, and an additonal 4 for write up and calculations.\n\n\nAI prototype\nContinuing my adventures with Claude, I gave it the prompt and this is the code it gave back.\n/* Quadrature Encoder Interface for STM32L432KC\n * Uses TIM2 in encoder mode with PA0 (CH1) and PA1 (CH2)\n * Hardware handles quadrature decoding automatically\n */\n\n#include \"stm32l4xx_hal.h\"\n\nTIM_HandleTypeDef htim2;\nvolatile int32_t encoder_position = 0;\nvolatile int32_t encoder_velocity = 0;\nvolatile uint32_t last_count = 0;\n\n/* Initialize TIM2 in encoder mode */\nvoid Encoder_Init(void)\n{\n    TIM_Encoder_InitTypeDef sConfig = {0};\n    TIM_MasterConfigTypeDef sMasterConfig = {0};\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n\n    /* Enable clocks */\n    __HAL_RCC_TIM2_CLK_ENABLE();\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    /* Configure GPIO pins PA0 and PA1 for TIM2_CH1 and TIM2_CH2 */\n    GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Pull = GPIO_PULLUP;  // Use pullup for encoder signals\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;\n    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n\n    /* Configure TIM2 in encoder mode */\n    htim2.Instance = TIM2;\n    htim2.Init.Prescaler = 0;\n    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;\n    htim2.Init.Period = 0xFFFFFFFF;  // 32-bit timer max value\n    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n    htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\n    \n    /* Encoder mode configuration - count on both edges of both channels */\n    sConfig.EncoderMode = TIM_ENCODERMODE_TI12;\n    sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;\n    sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;\n    sConfig.IC1Prescaler = TIM_ICPSC_DIV1;\n    sConfig.IC1Filter = 10;  // Input filter to debounce\n    sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;\n    sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;\n    sConfig.IC2Prescaler = TIM_ICPSC_DIV1;\n    sConfig.IC2Filter = 10;  // Input filter to debounce\n    \n    if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)\n    {\n        Error_Handler();\n    }\n\n    sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;\n    sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;\n    if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)\n    {\n        Error_Handler();\n    }\n\n    /* Set counter to middle position for bidirectional counting */\n    __HAL_TIM_SET_COUNTER(&htim2, 0x80000000);\n    last_count = 0x80000000;\n    \n    /* Start encoder interface */\n    HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);\n    \n    /* Optional: Enable update interrupt for overflow detection */\n    __HAL_TIM_ENABLE_IT(&htim2, TIM_IT_UPDATE);\n    HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);\n    HAL_NVIC_EnableIRQ(TIM2_IRQn);\n}\n\n/* Get current encoder position (relative to initialization) */\nint32_t Encoder_GetPosition(void)\n{\n    uint32_t current_count = __HAL_TIM_GET_COUNTER(&htim2);\n    encoder_position = (int32_t)(current_count - 0x80000000);\n    return encoder_position;\n}\n\n/* Reset encoder position to zero */\nvoid Encoder_Reset(void)\n{\n    __HAL_TIM_SET_COUNTER(&htim2, 0x80000000);\n    last_count = 0x80000000;\n    encoder_position = 0;\n}\n\n/* Get encoder direction: 1 = forward, -1 = backward, 0 = stopped */\nint8_t Encoder_GetDirection(void)\n{\n    if (__HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2))\n        return -1;\n    else if (__HAL_TIM_IS_TIM_COUNTING_UP(&htim2))\n        return 1;\n    return 0;\n}\n\n/* Calculate velocity (call this periodically, e.g., every 10ms) */\nint32_t Encoder_GetVelocity(void)\n{\n    uint32_t current_count = __HAL_TIM_GET_COUNTER(&htim2);\n    int32_t delta = (int32_t)(current_count - last_count);\n    last_count = current_count;\n    encoder_velocity = delta;\n    return encoder_velocity;\n}\n\n/* TIM2 Update interrupt handler - detects overflow/underflow */\nvoid TIM2_IRQHandler(void)\n{\n    if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE) != RESET)\n    {\n        if (__HAL_TIM_GET_IT_SOURCE(&htim2, TIM_IT_UPDATE) != RESET)\n        {\n            __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);\n            \n            /* Handle overflow/underflow if needed */\n            // With 32-bit counter, overflow is rare in practice\n        }\n    }\n}\n\n/* Optional: External interrupt approach for index pulse (Z channel)\n * Connect index pulse to PA10 (can use any GPIO with EXTI)\n */\nvoid Encoder_Index_Init(void)\n{\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n    \n    __HAL_RCC_GPIOA_CLK_ENABLE();\n    \n    GPIO_InitStruct.Pin = GPIO_PIN_10;\n    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;\n    GPIO_InitStruct.Pull = GPIO_PULLUP;\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n    \n    HAL_NVIC_SetPriority(EXTI15_10_IRQn, 1, 0);\n    HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);\n}\n\n/* Index pulse interrupt handler */\nvoid EXTI15_10_IRQHandler(void)\n{\n    if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_10) != RESET)\n    {\n        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_10);\n        \n        /* Reset position on index pulse */\n        Encoder_Reset();\n    }\n}\n\n/* Example usage in main.c */\nvoid Example_Usage(void)\n{\n    int32_t position, velocity;\n    int8_t direction;\n    \n    /* Initialize encoder */\n    Encoder_Init();\n    \n    /* Optional: Initialize index pulse */\n    // Encoder_Index_Init();\n    \n    while(1)\n    {\n        /* Read position (counts) */\n        position = Encoder_GetPosition();\n        \n        /* Read direction */\n        direction = Encoder_GetDirection();\n        \n        /* Calculate velocity (call at fixed intervals) */\n        velocity = Encoder_GetVelocity();\n        \n        /* Your application code here */\n        HAL_Delay(10);  // 10ms sample period for velocity\n    }\n}\n\nvoid Error_Handler(void)\n{\n    __disable_irq();\n    while (1)\n    {\n    }\n}\nLooking at this code it seems a little bit more complex than my solution. It doesn’t appear to be using some of the libraries we had access to. I did try and run this code but I got some errors, mainly with these libraries and things not being exactly correct. Over the past couple of prototypes I have found that AI has been better at C coding than SystemVerilog. I think this is because C is an actual coding language and it has debuggers while SystemVerilog is incredibly niche and is more of a translation of hardware."
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Introduction",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI was able to get the design working and I think I spent around 40 hours on this project. Probably would have been less if I had my brain working properly and was able to focus but I did get sick during this project so that is why it is not up to standards.\nIn this project I decided to power rows and take inputs of columns because this was the easiest way for me to understand. Another choice I made was using a bunch of enable signals that the entire system could talk to one another. The alternative is to include all possible states from the seperate modules together which would double the amount of states we need to use. The greater the amount of states the more output logic we have to keep track of and finding a bug in the states would have been way worse."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype",
    "href": "labs/lab3/lab3.html#ai-prototype",
    "title": "Introduction",
    "section": "AI Prototype",
    "text": "AI Prototype\nFor this AI prototype I wanted to try an AI that was not ChatGPT because in previous weeks ChatGPT hasn’t been giving the greatest code. So this weeek I used the recommended Claude. Here is the prompt I gave it: “Target device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:\nA clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.”\nHere is the code it gave me:\n// 4x4 Matrix Keypad Scanner with Dual 7-Segment Display\n// Target: Lattice iCE40 UP5K with ~20 MHz internal oscillator\n// Author: Claude\n// Date: 2025-09-29\n\n//==============================================================================\n// Top-level module\n//==============================================================================\nmodule keypad_display_top (\n    input  logic       clk_in,      // ~20 MHz internal oscillator\n    input  logic       rst_n,       // Active-low reset\n    \n    // Keypad interface (active-low)\n    output logic [3:0] col_out,     // Column drives (one low at a time)\n    input  logic [3:0] row_in,      // Row sense inputs\n    \n    // 7-segment display (common cathode, assuming multiplexed)\n    output logic [6:0] seg,         // Segments a-g (active high)\n    output logic [1:0] digit_sel    // Digit select (active high)\n);\n\n    // Internal signals\n    logic        scan_clk;          // ~100-200 Hz scanning clock\n    logic        display_clk;       // ~1 kHz display multiplexing clock\n    logic [3:0]  key_code;          // Current key pressed (0-F)\n    logic        key_valid;         // Pulse when new key registered\n    logic [3:0]  digit0, digit1;    // Two most recent keys (digit1 = newest)\n    \n    //--------------------------------------------------------------------------\n    // Clock dividers\n    //--------------------------------------------------------------------------\n    // Derive ~150 Hz scan clock (20 MHz / 133333 ≈ 150 Hz)\n    // and ~1 kHz display refresh (20 MHz / 20000 = 1 kHz)\n    clock_divider #(\n        .SCAN_DIV(133333),      // 150 Hz for keypad scanning\n        .DISPLAY_DIV(10000)     // 2 kHz for display (1 kHz per digit)\n    ) clk_div_inst (\n        .clk_in      (clk_in),\n        .rst_n       (rst_n),\n        .scan_clk    (scan_clk),\n        .display_clk (display_clk)\n    );\n    \n    //--------------------------------------------------------------------------\n    // Keypad scanner with debounce-by-design\n    //--------------------------------------------------------------------------\n    keypad_scanner scanner_inst (\n        .clk         (clk_in),\n        .rst_n       (rst_n),\n        .scan_clk    (scan_clk),\n        .row_in      (row_in),\n        .col_out     (col_out),\n        .key_code    (key_code),\n        .key_valid   (key_valid)\n    );\n    \n    //--------------------------------------------------------------------------\n    // Key history register\n    // Shifts in new keys: digit1 gets new key, digit0 gets old digit1\n    //--------------------------------------------------------------------------\n    always_ff @(posedge clk_in or negedge rst_n) begin\n        if (!rst_n) begin\n            digit0 &lt;= 4'h0;\n            digit1 &lt;= 4'h0;\n        end else if (key_valid) begin\n            digit0 &lt;= digit1;       // Shift older key\n            digit1 &lt;= key_code;     // Store newest key\n        end\n    end\n    \n    //--------------------------------------------------------------------------\n    // Time-multiplexed 7-segment display driver\n    //--------------------------------------------------------------------------\n    display_driver display_inst (\n        .clk         (clk_in),\n        .rst_n       (rst_n),\n        .display_clk (display_clk),\n        .digit0      (digit0),\n        .digit1      (digit1),\n        .seg         (seg),\n        .digit_sel   (digit_sel)\n    );\n\nendmodule\n\n\n//==============================================================================\n// Clock divider module\n// Generates slow clocks from the high-speed oscillator\n//==============================================================================\nmodule clock_divider #(\n    parameter int SCAN_DIV    = 133333,  // Divider for scan clock (~150 Hz)\n    parameter int DISPLAY_DIV = 10000    // Divider for display clock (~2 kHz)\n)(\n    input  logic clk_in,\n    input  logic rst_n,\n    output logic scan_clk,\n    output logic display_clk\n);\n\n    logic [$clog2(SCAN_DIV)-1:0]    scan_counter;\n    logic [$clog2(DISPLAY_DIV)-1:0] display_counter;\n    \n    // Scan clock generation\n    always_ff @(posedge clk_in or negedge rst_n) begin\n        if (!rst_n) begin\n            scan_counter &lt;= '0;\n            scan_clk     &lt;= 1'b0;\n        end else begin\n            if (scan_counter == SCAN_DIV - 1) begin\n                scan_counter &lt;= '0;\n                scan_clk     &lt;= 1'b1;  // Single-cycle pulse\n            end else begin\n                scan_counter &lt;= scan_counter + 1;\n                scan_clk     &lt;= 1'b0;\n            end\n        end\n    end\n    \n    // Display multiplex clock generation\n    always_ff @(posedge clk_in or negedge rst_n) begin\n        if (!rst_n) begin\n            display_counter &lt;= '0;\n            display_clk     &lt;= 1'b0;\n        end else begin\n            if (display_counter == DISPLAY_DIV - 1) begin\n                display_counter &lt;= '0;\n                display_clk     &lt;= 1'b1;  // Single-cycle pulse\n            end else begin\n                display_counter &lt;= display_counter + 1;\n                display_clk     &lt;= 1'b0;\n            end\n        end\n    end\n\nendmodule\n\n\n//==============================================================================\n// Keypad scanner with debounce-by-design\n// Scans columns sequentially, samples rows, and registers one key per press\n//==============================================================================\nmodule keypad_scanner (\n    input  logic       clk,         // System clock\n    input  logic       rst_n,       // Active-low reset\n    input  logic       scan_clk,    // Scan tick (~150 Hz)\n    input  logic [3:0] row_in,      // Row inputs (active-low)\n    output logic [3:0] col_out,     // Column outputs (active-low, one at a time)\n    output logic [3:0] key_code,    // Detected key code (0-F)\n    output logic       key_valid    // Pulse when new key registered\n);\n\n    // FSM states\n    typedef enum logic [1:0] {\n        IDLE,           // No key pressed, scanning\n        KEY_DETECTED,   // Key detected, register and wait for release\n        WAIT_RELEASE    // Waiting for all keys to be released\n    } state_t;\n    \n    state_t state, state_next;\n    \n    // Column scanning (one-hot active-low)\n    logic [1:0] col_index;          // Which column is active (0-3)\n    logic [3:0] col_out_reg;\n    \n    // Key detection\n    logic       any_key_pressed;    // True if any row is low (key pressed)\n    logic [3:0] key_code_reg;\n    logic       key_valid_reg;\n    \n    // Combinational: check if any key is currently pressed\n    assign any_key_pressed = (row_in != 4'b1111);\n    \n    //--------------------------------------------------------------------------\n    // Column scanner: cycles through columns on each scan_clk\n    //--------------------------------------------------------------------------\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            col_index &lt;= 2'b00;\n        end else if (scan_clk && state == IDLE) begin\n            col_index &lt;= col_index + 1;  // Wrap around 0-3\n        end\n    end\n    \n    // Generate active-low column output (one-hot)\n    always_comb begin\n        col_out_reg = 4'b1111;  // All high (inactive)\n        col_out_reg[col_index] = 1'b0;  // Drive selected column low\n    end\n    \n    assign col_out = col_out_reg;\n    \n    //--------------------------------------------------------------------------\n    // Key code calculation from row and column\n    //--------------------------------------------------------------------------\n    function automatic logic [3:0] calc_key_code(logic [1:0] col, logic [3:0] row);\n        logic [3:0] code;\n        // Standard 4x4 keypad layout (hex):\n        // Row 0: 1 2 3 A\n        // Row 1: 4 5 6 B\n        // Row 2: 7 8 9 C\n        // Row 3: * 0 # D  (mapping * to E, # to F)\n        case ({col, row})\n            // Column 0\n            6'b00_1110: code = 4'h1;  // Row 0, Col 0\n            6'b00_1101: code = 4'h4;  // Row 1, Col 0\n            6'b00_1011: code = 4'h7;  // Row 2, Col 0\n            6'b00_0111: code = 4'hE;  // Row 3, Col 0 (*)\n            \n            // Column 1\n            6'b01_1110: code = 4'h2;  // Row 0, Col 1\n            6'b01_1101: code = 4'h5;  // Row 1, Col 1\n            6'b01_1011: code = 4'h8;  // Row 2, Col 1\n            6'b01_0111: code = 4'h0;  // Row 3, Col 1\n            \n            // Column 2\n            6'b10_1110: code = 4'h3;  // Row 0, Col 2\n            6'b10_1101: code = 4'h6;  // Row 1, Col 2\n            6'b10_1011: code = 4'h9;  // Row 2, Col 2\n            6'b10_0111: code = 4'hF;  // Row 3, Col 2 (#)\n            \n            // Column 3\n            6'b11_1110: code = 4'hA;  // Row 0, Col 3\n            6'b11_1101: code = 4'hB;  // Row 1, Col 3\n            6'b11_1011: code = 4'hC;  // Row 2, Col 3\n            6'b11_0111: code = 4'hD;  // Row 3, Col 3\n            \n            default:    code = 4'h0;  // No valid key\n        endcase\n        return code;\n    endfunction\n    \n    //--------------------------------------------------------------------------\n    // FSM: debounce-by-design state machine\n    //--------------------------------------------------------------------------\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state &lt;= IDLE;\n        end else begin\n            state &lt;= state_next;\n        end\n    end\n    \n    always_comb begin\n        state_next = state;\n        \n        case (state)\n            IDLE: begin\n                // Scanning columns, looking for a key press\n                if (scan_clk && any_key_pressed) begin\n                    state_next = KEY_DETECTED;\n                end\n            end\n            \n            KEY_DETECTED: begin\n                // Key registered, now wait for release\n                state_next = WAIT_RELEASE;\n            end\n            \n            WAIT_RELEASE: begin\n                // Wait until all keys released before accepting new press\n                if (scan_clk && !any_key_pressed) begin\n                    state_next = IDLE;\n                end\n            end\n            \n            default: state_next = IDLE;\n        endcase\n    end\n    \n    //--------------------------------------------------------------------------\n    // Output registration\n    // Generate key_valid pulse and latch key_code when transitioning to KEY_DETECTED\n    //--------------------------------------------------------------------------\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            key_code_reg  &lt;= 4'h0;\n            key_valid_reg &lt;= 1'b0;\n        end else begin\n            if (state == IDLE && state_next == KEY_DETECTED) begin\n                // Capture key code at the moment of detection\n                key_code_reg  &lt;= calc_key_code(col_index, row_in);\n                key_valid_reg &lt;= 1'b1;  // Pulse for one cycle\n            end else begin\n                key_valid_reg &lt;= 1'b0;\n            end\n        end\n    end\n    \n    assign key_code  = key_code_reg;\n    assign key_valid = key_valid_reg;\n\nendmodule\n\n\n//==============================================================================\n// 7-segment display driver with time multiplexing\n// Alternates between two digits at ~1 kHz rate for flicker-free display\n//==============================================================================\nmodule display_driver (\n    input  logic       clk,\n    input  logic       rst_n,\n    input  logic       display_clk,  // Multiplex clock (~2 kHz)\n    input  logic [3:0] digit0,       // Older digit (left)\n    input  logic [3:0] digit1,       // Newer digit (right)\n    output logic [6:0] seg,          // 7-segment outputs a-g\n    output logic [1:0] digit_sel     // Digit selection (one-hot)\n);\n\n    logic       current_digit;      // Which digit to display (0 or 1)\n    logic [3:0] hex_value;\n    \n    // Alternate between digits on each display_clk tick\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            current_digit &lt;= 1'b0;\n        end else if (display_clk) begin\n            current_digit &lt;= ~current_digit;\n        end\n    end\n    \n    // Select which hex value to display\n    assign hex_value = current_digit ? digit1 : digit0;\n    \n    // Generate digit select signals (one-hot active high)\n    assign digit_sel = current_digit ? 2'b10 : 2'b01;\n    \n    // Hex to 7-segment decoder\n    // Segments: {g, f, e, d, c, b, a} - active high\n    always_comb begin\n        case (hex_value)\n            4'h0: seg = 7'b0111111;  // 0\n            4'h1: seg = 7'b0000110;  // 1\n            4'h2: seg = 7'b1011011;  // 2\n            4'h3: seg = 7'b1001111;  // 3\n            4'h4: seg = 7'b1100110;  // 4\n            4'h5: seg = 7'b1101101;  // 5\n            4'h6: seg = 7'b1111101;  // 6\n            4'h7: seg = 7'b0000111;  // 7\n            4'h8: seg = 7'b1111111;  // 8\n            4'h9: seg = 7'b1101111;  // 9\n            4'hA: seg = 7'b1110111;  // A\n            4'hB: seg = 7'b1111100;  // b\n            4'hC: seg = 7'b0111001;  // C\n            4'hD: seg = 7'b1011110;  // d\n            4'hE: seg = 7'b1111001;  // E\n            4'hF: seg = 7'b1110001;  // F\n            default: seg = 7'b0000000;  // Blank\n        endcase\n    end\n\nendmodule\nOne thing I found interesting between it and my code is that it only used 3 states in their FSM. This is what I had originally planned on but couldn’t get it to work. When I did try to run the code I got some errors that made it unable to synthesize but overall it seems similar to the code I have written. I woner if it could be used to bebug my code well since I found forums weren’t as helpful when I was debugging."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Beginning of Semester reflection",
    "section": "",
    "text": "E155 is known as one of the hardest courses at mudd and so I’m defiently scared of what lies ahead. I know that this class will be hard but I hope it helps me solidfy being able to think in circuits vs code since that was a large downfall in E85. I also think being able to effectively debug a program."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This portfolio uses the Harvey Mudd College E155 site."
  },
  {
    "objectID": "resources.html#resources",
    "href": "resources.html#resources",
    "title": "E155 Portfolio",
    "section": "",
    "text": "This portfolio uses the Harvey Mudd College E155 site."
  }
]